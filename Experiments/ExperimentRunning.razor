@using sip.Experiments.Logs
@using sip.Experiments.Model
@inject IExperimentLogProvider LogProvider
@inject DocumentService DocumentService
@inject ExperimentsService ExperimentsService
@inject ILogger<ExperimentRunning> Logger
@implements IDisposable

<div class="exp-status-bar status-@Exp.State d-flex align-items-center p-3">
    
    <div class="exp-overview flex-grow-1">
        <div class="fw-bold">@Exp.SecondaryId / @Exp.Sample.Name</div>
        
        <div class="small">
            @Exp.Operator.Fullname -&gt; @Exp.User.Fullname <br/> @Exp.Storage.SourceDirectory -&gt; @Exp.Storage.Path
        </div>
        <em>Started @Exp.DtCreated.HappenAgo(), last log @((_lastLog?.Dt ?? Exp.DtCreated).HappenAgo(stripSeconds: false))</em>
        @* @if (MightBeDone) *@
        @* { *@
        @*     <em> - experiment is probably finished and ready to be terminated</em> *@
        @* } *@
        @* else *@
        @* { *@
        @*     <em> - experiment is probably still in progress</em> *@
        @* } *@
    </div>
    
    <div class="mx-5 text-nowrap">
        <span class="fs-5"><i class="fa fa-spinner fa-spin fs-5"></i> &nbsp; @Exp.State.Humanize() ...</span> 
        <div class="lh-1">
            <span class="small">St: @Exp.Storage.State.Humanize() @(string.IsNullOrWhiteSpace(Exp.Storage.Node) ? ", -" : $", {Exp.Storage.Node}")</span> <br/>
            <span class="small">Pr: @Exp.Processing.State.Humanize() @(string.IsNullOrWhiteSpace(Exp.Processing.Node) ? ", -" : $", {Exp.Processing.Node}")</span> <br/>
            <span class="small">Pu: @Exp.Publication.State.Humanize() @(string.IsNullOrWhiteSpace(Exp.Publication.Node) ? ", -" : $", {Exp.Publication.Node}")</span>
        </div>
    </div>
    
    <div class="flex-static-25">
        @if (Exp.State == ExpState.Active)
        {
            <InteractiveButtonForm TFormModel="ExperimentStopModel"
                                   Model="@_stopModel"
                                   Caption="Stop aquisition" BtnClass="w-100 btn btn-sm btn-danger" TooltipDirection="@TooltipDirection.BottomLeft"
                                   OnSubmit="@_StopJobRequest"
                                   Context="stopForm">
            </InteractiveButtonForm>

            <em class="d-block p-1 text-muted small text-center">Please stop the acquisition once desired data are 
                transferred and no more are expected to be generated by the instrument</em>
        }
    </div>

</div>

<div class="exp-log-results-container">
    <div>
        <CEditForm Model="@Exp" TModelType="Experiment" FormFooter="@(CEditForm<Experiment>.EmptyFooter)">
            <CTextInput Sizing="Sizing.Small" Flex="0, 1" @bind-Value="@Exp.Notes"
                        OnValueSet="_SaveExperimentNotes"/>
        </CEditForm>
        
        <Loglist @ref="@_logListComponent" LogsProvider="@_logsProvider"/>
    </div>
    
    @* In cas there is some processing, show results *@
    @* There are possibly multiple documents and files, make it possible to select between them *@
    @if (!string.IsNullOrEmpty(Exp.Processing.ProcessingEngine))
    {
        <div class="results d-flex flex-column">
            <CEditForm Model="@this" FormFooter="@(CEditForm<ExperimentRunning>.EmptyFooter)">
                <CSelectDropdown @bind-Value="@_currentFilePreview" TItem="FileMetadata"
                                 HasLabel="@false"
                                 EqualityComparer="@(IdEqualityComparer<FileMetadata, Guid>.Comparer)"
                                 ItemsProvider="@_docItemsProvider" 
                                 DisplayNameMapper="_docDisplayNameMapper" />
            </CEditForm>
            
            <FilePreview class="flex-grow-1" FileMetadata="@_currentFilePreview"></FilePreview>
        </div>
    }
    
</div>

@code {
    
    [Parameter] 
    public IExperimentHandler ExpHandler { get; set; } = null!;

    [Parameter]
    public Experiment Exp { get; set; } = null!;
    private Experiment? _prevExp = null!;

    private Log? _lastLog;

    // TODO - make this configurable per experiment type...
    private bool MightBeDone => (DateTime.UtcNow - (_lastLog?.Dt ?? Exp.DtCreated)) > TimeSpan.FromMinutes(1);

    protected override void OnInitialized()
    {
        ExpHandler.ExperimentLogAdded += OnExpHandlerOnExperimentLogAdded;
        _stopModel = new ExperimentStopModel();
    }
    
    public void Dispose()
    {
        ExpHandler.ExperimentLogAdded -= OnExpHandlerOnExperimentLogAdded;
    }

    private async void OnExpHandlerOnExperimentLogAdded(IReadOnlyCollection<Log> logs)
    {
        if (_logListComponent is not null && logs.Any(l => l.ExperimentId == Exp.Id))
        {
            await _logListComponent.ReloadLogsAsync(true);
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        var logLast = await LogProvider.GetLogsAsync(Exp, LogLevel.Information, new ItemsProviderRequest(0, 1, default));
        _lastLog = logLast.Items.FirstOrDefault();
        
        await DocumentService.LoadDocumentAsync(Exp.Processing.ResultReport);

        var lastLogReports = Exp.Processing.LogReport.FilesInDocuments;
        await DocumentService.LoadDocumentAsync(Exp.Processing.LogReport);
        // foreach (var logReportFilesInDocument in Exp.Processing.LogReport.FilesInDocuments)
        // {
        //     Logger.LogTrace(" reference eq={RefEq}", ReferenceEquals());
        // }
        Logger.LogTrace("refeq find={}, c0 {}, c1 {}", lastLogReports.SequenceEqual(Exp.Processing.LogReport.FilesInDocuments), lastLogReports.Count, Exp.Processing.LogReport.FilesInDocuments.Count);
        Logger.LogTrace("refeq fmeta={}", lastLogReports.Select(l=>l.FileMetadata).SequenceEqual(Exp.Processing.LogReport.FilesInDocuments.Select(f=>f.FileMetadata)));
        
        if (_currentFilePreview is null)
        {
            // Select first item
            var items = (await _docItemsProvider(default)).Items;
            _currentFilePreview = items.FirstOrDefault();
            Logger.LogTrace("Set default file preview {Id}", _currentFilePreview?.Id);
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // To reload logs on changing the experiment parameter
        if (!IdEqualityComparer<Experiment, Guid>.Comparer.Equals(_prevExp, Exp))
        {
            _prevExp = Exp;
            if (_logListComponent is not null) 
                await _logListComponent.ReloadLogsAsync();
        }
    }


    public FileMetadata? _currentFilePreview;
    private Loglist? _logListComponent;
    private ExperimentStopModel _stopModel = null!;

    private ValueTask<ItemsProviderResult<FileMetadata>> _docItemsProvider(ItemsProviderRequest request)
    {
        var resultReportFiles = Exp.Processing.ResultReport.ActivePrimaryFiles.Select(a => a.FileMetadata);
        var logReportFiles = Exp.Processing.LogReport.ActivePrimaryFiles.Select(a => a.FileMetadata);

        var all = resultReportFiles.Concat(logReportFiles).ToArray();
        return new ValueTask<ItemsProviderResult<FileMetadata>>(new ItemsProviderResult<FileMetadata>(all, all.Length));
    }

    private string _docDisplayNameMapper(FileMetadata arg) => arg.FileName;

    private async Task _StopJobRequest(ExperimentStopModel stopModel)
    {
        Logger.LogTrace("Stop job request handler");
        await ExpHandler.RequestStop(Exp, stopModel);
    }

    private ValueTask<ItemsProviderResult<Log>> _logsProvider(ItemsProviderRequest request)
    {
        return LogProvider.GetLogsAsync(Exp, LogLevel.Debug, request);
    }

    private Task _SaveExperimentNotes(string _) => 
        ExperimentsService.UpdatePropertyAsync(Exp, e => e.Notes);
}