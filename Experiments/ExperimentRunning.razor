@using sip.Documents
@using sip.Experiments.Logs
@using sip.Experiments.Model
@using sip.Forms
@using sip.Utils
@inject IExperimentLogProvider LogProvider
@inject DocumentService DocumentService
@inject ExperimentsService ExperimentsService

<div class="exp-status-bar status-@Exp.State d-flex align-items-center p-2">
    
    <div class="exp-overview flex-grow-1">
        <div class="fw-bold">@Exp.SecondaryId / @Exp.Sample.Name</div>
        
        <div>@Exp.Operator.Fullname -&gt; @Exp.User.Fullname</div>
        <em>Started @Exp.DtCreated.HappenAgo(), last log @((_lastLog?.Dt ?? Exp.DtCreated).HappenAgo(stripSeconds: false))</em>
        @if (MightBeDone)
        {
            <em> - experiment is probably finished and ready to be terminated</em>
        }
        else
        {
            <em> - experiment is probably still in progress</em>
        }
    </div>
    
    <div class="mx-5 text-nowrap">
        <span class="fs-5"><i class="fa fa-spinner fa-spin fs-5"></i> &nbsp; @Exp.State.Humanize() ...</span> 
        <div class="lh-1">
            <span class="small">St: @Exp.Storage.State.Humanize() @(string.IsNullOrWhiteSpace(Exp.Storage.Node) ? ", -" : $", {Exp.Storage.Node}")</span> <br/>
            <span class="small">Pr: @Exp.Processing.State.Humanize() @(string.IsNullOrWhiteSpace(Exp.Processing.Node) ? ", -" : $", {Exp.Processing.Node}")</span> <br/>
            <span class="small">Pu: @Exp.Publication.State.Humanize() @(string.IsNullOrWhiteSpace(Exp.Publication.Node) ? ", -" : $", {Exp.Publication.Node}")</span>
        </div>
    </div>
    
    <div class="flex-static-25">
        @if (Exp.State == ExpState.Active)
        {
            <InteractiveButton Caption="Stop acquisition"
                               BtnClass="w-100 btn btn-sm btn-danger"
                               TooltipDirection="@TooltipDirection.BottomLeft"
                               OnClick="@_StopJobRequest">
                
                <ConfirmTemplate Context="button">
                    <CEditForm class="m-2" TModelType="Experiment" Model="Exp"
                               OnSubmit="@(() => button.ConfirmAsync())"
                               OnCancel="@(() => button.CancelAsync())">

                        <CTextInput Sizing="Sizing.Small" Flex="0, 1" @bind-Value="@Exp.Notes"></CTextInput>
                        <CCheckBox HasLabel="@false" @bind-Value="@Exp.NotifyUser"></CCheckBox>

                    </CEditForm>
                </ConfirmTemplate>
            </InteractiveButton>

            <em class="d-block p-1 text-center">Please stop the acquisition once desired data are transfered and no more are expected to be generated by the instrument</em>
        }
    </div>

</div>

<div class="exp-log-results-container">
    <Loglist Autorefresh="@true" LogsProvider="@_logsProvider"></Loglist>
    
    @* In cas there is some processing, show results *@
    @* There are possibly multiple documents and files, make it possible to select between them *@
    @if (!string.IsNullOrEmpty(Exp.Processing.ProcessingEngine))
    {
        <div class="results d-flex flex-column">
            <CEditForm Model="@this" FormFooter="@(CEditForm<ExperimentRunning>.EmptyFooter)">
                <CSelectDropdown @bind-Value="@_currentFilePreview" TItem="FileMetadata"
                                 HasLabel="@false"
                                 ItemsProvider="@_docItemsProvider" 
                                 DisplayNameMapper="_docDisplayNameMapper"></CSelectDropdown>
            </CEditForm>
            
            <FilePreview class="flex-grow-1" FileMetadata="@_currentFilePreview"></FilePreview>
        </div>
    }
    
</div>

@code {
    
    [Parameter] 
    public IExperimentHandler ExpHandler { get; set; } = null!;

    [Parameter]
    public Experiment Exp { get; set; } = null!;

    private Log? _lastLog;

    // TODO - make this configurable per experiment type...
    private bool MightBeDone => (DateTime.UtcNow - (_lastLog?.Dt ?? Exp.DtCreated)) > TimeSpan.FromMinutes(1);

    protected override async Task OnParametersSetAsync()
    {
        if (_logListComponent is not null)
        {
            await _logListComponent.RefreshAsync();
        }

        var logLast = await LogProvider.GetLogsAsync(Exp, LogLevel.Information, new ItemsProviderRequest(0, 1, default));
        _lastLog = logLast.Items.FirstOrDefault();

        await DocumentService.LoadDocumentAsync(Exp.Processing.ResultReport);
        await DocumentService.LoadDocumentAsync(Exp.Processing.LogReport);
        
        if (_currentFilePreview is null)
        {
            _currentFilePreview = Exp.Processing.ResultReport.ActivePrimaryFiles.FirstOrDefault()?.FileMetadata;
        }
    }


    private LogLIstTabbed? _logListComponent;
    public FileMetadata? _currentFilePreview;

    private ValueTask<ItemsProviderResult<FileMetadata>> _docItemsProvider(ItemsProviderRequest request)
    {
        var resultReportFiles = Exp.Processing.ResultReport.ActivePrimaryFiles.Select(a => a.FileMetadata);
        var logReportFiles = Exp.Processing.LogReport.ActivePrimaryFiles.Select(a => a.FileMetadata);

        var all = resultReportFiles.Concat(logReportFiles).ToArray();
        return new ValueTask<ItemsProviderResult<FileMetadata>>(new ItemsProviderResult<FileMetadata>(all, all.Length));
    }

    private string _docDisplayNameMapper(FileMetadata arg) => arg.FileName;

    private async Task _StopJobRequest()
    {
        Console.WriteLine("Stop job request handler");
        await ExpHandler.RequestStop(Exp);
    }

    private ValueTask<ItemsProviderResult<Log>> _logsProvider(ItemsProviderRequest request)
    {
        return LogProvider.GetLogsAsync(Exp, LogLevel.Debug, request);
    }

}